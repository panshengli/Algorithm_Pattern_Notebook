<!DOCTYPE html>
<html>
<head>
<title>003_sort_algorithm.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/* https://github.com/microsoft/vscode/blob/master/extensions/markdown-language-features/media/markdown.css */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: var(--vscode-markdown-font-family, -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif);
	font-size: var(--vscode-markdown-font-size, 14px);
	padding: 0 26px;
	line-height: var(--vscode-markdown-line-height, 22px);
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}

body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-light.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-dark.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

.vscode-high-contrast.showEditorSelection .code-line .code-line:hover:before {
	border-left: none;
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	text-decoration: none;
}

a:hover {
	text-decoration: underline;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left-width: 5px;
	border-left-style: solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 1em;
	line-height: 1.357em;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

pre code {
	color: var(--vscode-editor-foreground);
	tab-size: 4;
}

/** Theming */

.vscode-light pre {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family: -apple-system, BlinkMacSystemFont, "Segoe WPC", "Segoe UI", "Ubuntu", "Droid Sans", sans-serif, "Meiryo";
	padding: 0 12px;
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

code {
	font-size: 14px;
	line-height: 19px;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

<script src="https://unpkg.com/mermaid/dist/mermaid.min.js"></script>
</head>
<body>
  <script>
    mermaid.initialize({
      startOnLoad: true,
      theme: document.body.classList.contains('vscode-dark') || document.body.classList.contains('vscode-high-contrast')
          ? 'dark'
          : 'default'
    });
  </script>
<h2 id="search-algorithm">Search Algorithm</h2>
<ul>
<li>各种排序算法指标对比
<table>
<thead>
<tr>
<th style="text-align:center">排序方法</th>
<th style="text-align:center">平均情况</th>
<th style="text-align:center">最好情况</th>
<th style="text-align:center">最坏情况</th>
<th style="text-align:center">辅助空间</th>
<th style="text-align:center">稳定性</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">冒泡排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">简单选择排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">直接插入排序</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">稳定</td>
</tr>
<tr>
<td style="text-align:center">希尔排序</td>
<td style="text-align:center">O(nlogn)~O(n2)</td>
<td style="text-align:center">O(n1.3)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(1)</td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center"><strong>堆排序</strong></td>
<td style="text-align:center"><strong>O(nlogn)</strong></td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center"><strong>O(1)</strong></td>
<td style="text-align:center">不稳定</td>
</tr>
<tr>
<td style="text-align:center"><strong>归并排序</strong></td>
<td style="text-align:center"><strong>O(nlogn)</strong></td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n)</td>
<td style="text-align:center"><strong>稳定</strong></td>
</tr>
<tr>
<td style="text-align:center"><strong>快速排序</strong></td>
<td style="text-align:center"><strong>O(nlogn)</strong></td>
<td style="text-align:center">O(nlogn)</td>
<td style="text-align:center">O(n2)</td>
<td style="text-align:center">O(logn)~O(n)</td>
<td style="text-align:center">不稳定</td>
</tr>
</tbody>
</table>
</li>
<li>稳定：如果a原本在b前面，而a=b，排序之后a仍然在b的前面</li>
<li>不稳定：如果a原本在b的前面，而a=b，排序之后a可能会在b的后面</li>
<li><strong>归并排序与快排</strong>：
<ul>
<li>
<ol>
<li>都是分治思想，但分解和合并的策略不一样</li>
</ol>
</li>
<li>
<ol start="2">
<li>归并是从中间分两个，合并后两个数列再次排序</li>
</ol>
</li>
<li>
<ol start="3">
<li>快排是比较后，小的在左大的在右，直接合并不再需要排序</li>
</ol>
</li>
<li>所以<strong>快排比归并排序更高效</strong>一些</li>
</ul>
</li>
</ul>
<hr>
<h2 id="%F0%9F%93%91-index">📑 index</h2>
<ul>
<li>mergeSort &amp; quickSort and heapSort
<ul>
<li><a href="#mergeSort">1. [代码框架] mergeSort</a></li>
<li><a href="#quickSort">2. [代码框架] quickSort</a></li>
<li><a href="./005_lists_structure.md">3. [003_lists_structure 5&amp;7] merge-sort</a></li>
<li><a href="#sc">4. [<strong>很棒的数组mergeSort</strong>] sort-colors(#75)</a></li>
<li><a href="#kleiaa">5. [<strong>数组quickSort</strong>] kth-largest-element-in-an-array(#215)</a></li>
<li><a href="#tkfe">6. [<strong>数组heapSort</strong>] top-k-frequent-elements(#347)</a></li>
</ul>
</li>
</ul>
<ul>
<li><a href="#bubbleSort">7. [代码框架] bubbleSort</a></li>
<li><a href="#selectSort">8. [代码框架] selectSort</a></li>
<li><a href="#insertSort">9. [代码框架] insertSort</a></li>
</ul>
<div id="mergeSort" onclick="window.location.hash">
<h4 id="1-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-mergesort">1. [代码框架] mergeSort</h4>
<ul>
<li>排序思想：
<ol>
<li>将序列一分为二，对两边进行递归分割操作，得到独立子序列</li>
<li>对独立子序列递归的执行合并操作，得到有序的序列,如下图
<img src=".readme/merge_sort.gif" alt="" title="mergeSort"></li>
</ol>
</li>
<li>python版本<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge</span><span class="hljs-params">(left, right)</span>:</span>
    l = <span class="hljs-number">0</span>
    r = <span class="hljs-number">0</span>
    m = []
    <span class="hljs-keyword">while</span> l &lt; len(left) <span class="hljs-keyword">and</span> r &lt; len(right):
        <span class="hljs-keyword">if</span> left[l] &lt;= right[r]:
            m.append(left[l])
            l += <span class="hljs-number">1</span>
        <span class="hljs-keyword">else</span>:
            m.append(right[r])
            r += <span class="hljs-number">1</span>
    remains = right[r:] <span class="hljs-keyword">if</span> l == len(left) <span class="hljs-keyword">else</span> left[l:]
    m.extend(remains)
    <span class="hljs-keyword">return</span> m

<span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">merge_sort</span><span class="hljs-params">(arr)</span>:</span>
    <span class="hljs-keyword">if</span> len(arr) &lt;= <span class="hljs-number">1</span>:
        <span class="hljs-keyword">return</span> arr
    middle = len(arr) // <span class="hljs-number">2</span>
    left = merge_sort(arr[:middle])
    right = merge_sort(arr[middle:])
    <span class="hljs-keyword">return</span> merge(left, right)
</div></code></pre>
</li>
</ul>
<hr>
<div id="quickSort" onclick="window.location.hash">
<h4 id="2-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-quicksort">2. [代码框架] quickSort</h4>
<ul>
<li>排序思想：
<ul>
<li>基于分治思想的不稳定排序(基准前后放在一边)</li>
<li>快速排序缺点：<strong>对小规模数据性能不是很好</strong></li>
<li>快排是原地交换，无合并过程传入的索引是存在的索引（如：0、length-1等），<strong>越界可能导致崩溃</strong>,如下图
<img src=".readme/quick_sort.gif" alt="" title="quickSort"></li>
</ul>
</li>
<li>python版本<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">quick_sort</span><span class="hljs-params">(b)</span>:</span>
    <span class="hljs-string">"""快速排序"""</span>
    <span class="hljs-keyword">if</span> len(b) &lt; <span class="hljs-number">2</span>:
        <span class="hljs-keyword">return</span> arr
    <span class="hljs-comment"># 选取基准，随便选哪个都可以，选中间的便于理解</span>
    pivot = arr[len(b) // <span class="hljs-number">2</span>]
    <span class="hljs-comment"># 定义基准值左右两个数列</span>
    left, right = [], []
    <span class="hljs-comment"># 从原始数组中移除基准值</span>
    b.remove(pivot)
    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> b:
        <span class="hljs-comment"># 大于基准值放右边</span>
        <span class="hljs-keyword">if</span> item &gt;= pivot:
            right.append(item)
        <span class="hljs-keyword">else</span>:
            <span class="hljs-comment"># 小于基准值放左边</span>
            left.append(item)
    <span class="hljs-comment"># 使用迭代进行比较</span>
    <span class="hljs-keyword">return</span> quick_sort(left) + [pivot] + quick_sort(right)
</div></code></pre>
</li>
</ul>
<hr>
<div id="sc" onclick="window.location.hash">
<h4 id="4-%E6%95%B0%E7%BB%84mergesort-sort-colors75">4. [数组mergeSort] sort-colors(#75)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/sort-colors/" title="颜色分类">leetcode</a></p>
<ul>
<li>n个元素的<strong>数组</strong>，原地对它们进行排序</li>
<li>思路一：mergeSort
<ul>
<li>
<ol>
<li>数组的合并方式，开辟临时变量</li>
</ol>
</li>
<li>
<ol start="2">
<li>将临时变量的数组最终合并到nums</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">sortColors</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span> 
    </span>{
        <span class="hljs-keyword">if</span>(nums.size() == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">int</span> start = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> end = nums.size() - <span class="hljs-number">1</span>;
        mergeSort(nums, start, end);
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span>
    </span>{
        <span class="hljs-keyword">int</span> mid = start + ((end - start) &gt;&gt; <span class="hljs-number">1</span>);
        <span class="hljs-keyword">if</span>(end - start &gt; <span class="hljs-number">0</span>)
        {
            mergeSort(nums, start, mid);
            mergeSort(nums, mid + <span class="hljs-number">1</span>, end);
            mergeTwoNums(nums, start, end);
        }
    }
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">mergeTwoNums</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> start, <span class="hljs-keyword">int</span> end)</span>
    </span>{
        <span class="hljs-keyword">int</span> length = end - start + <span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> mid = start + ((end - start)&gt;&gt;<span class="hljs-number">1</span>);
        <span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; tmp;
        tmp.resize(length);
        <span class="hljs-keyword">int</span> index = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> lhs = start;
        <span class="hljs-keyword">int</span> rhs = mid +<span class="hljs-number">1</span>;
        <span class="hljs-comment">// 判断两组nums是否越界</span>
        <span class="hljs-keyword">while</span>(lhs &lt;= mid &amp;&amp; rhs &lt;= end)
        {
            <span class="hljs-keyword">if</span>(nums[lhs] &lt;= nums[rhs])
            {
                tmp[index++] = nums[lhs++];
            }
            <span class="hljs-keyword">else</span>
            {
                tmp[index++] = nums[rhs++];
            }
        }
        <span class="hljs-comment">// 遍历剩余的数组</span>
        <span class="hljs-keyword">while</span>(lhs &lt;= mid)
        {
            tmp[index++] = nums[lhs++];
        }
        <span class="hljs-keyword">while</span>(rhs &lt;= end)
        {
            tmp[index++] = nums[rhs++];
        }
        <span class="hljs-comment">// 重点：合并tmp数组到nums中</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; length; i++)
        {
            nums[start + i] = tmp[i];
        }
    }
};
</div></code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<div id="kleiaa" onclick="window.location.hash">
<h4 id="5-%E6%95%B0%E7%BB%84quicksort-kth-largest-element-in-an-array215">5. [<strong>数组quickSort</strong>] kth-largest-element-in-an-array(#215)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array/" title="数组中的第K个最大元素">leetcode</a></p>
<ul>
<li>在未排序的数组中找到第k个最大的元素</li>
<li>思路一： quickSort(未优化)<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span>
    </span>{
        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> high = nums.size()<span class="hljs-number">-1</span>;
        quickSort(nums, low, high);
        <span class="hljs-keyword">return</span> nums[nums.size()-k];
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span>
    </span>{
        <span class="hljs-comment">// 2. 尾递归用while，普通情况if判断</span>
        <span class="hljs-keyword">if</span>(high-low &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">int</span> pivot = partition(nums, low, high);
            quickSort(nums, low, pivot - <span class="hljs-number">1</span>);
            quickSort(nums, pivot + <span class="hljs-number">1</span>, high);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span>
    </span>{
        <span class="hljs-keyword">int</span> pivotKey = nums[low];
        <span class="hljs-keyword">while</span>(high-low &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-comment">//从两边向中间逼近</span>
            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= pivotKey)
            {
                high -- ;
            }
            nums[low] = nums[high];
            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= pivotKey)
            {
                low ++;
            }
            nums[high] = nums[low];
        }
        <span class="hljs-comment">// 重点：减少不必要的交换后要还原nums[low]</span>
        nums[low] = pivotKey;
        <span class="hljs-keyword">return</span> low;
    }
};
</div></code></pre>
</li>
<li>思路二： quickSort(优化版)<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> 
    </span>{
        <span class="hljs-keyword">int</span> low = <span class="hljs-number">0</span>;
        <span class="hljs-keyword">int</span> high = nums.size()<span class="hljs-number">-1</span>;
        quickSort(nums, low, high);
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x:nums)
        {
            <span class="hljs-built_in">cout</span>&lt;&lt;<span class="hljs-string">"nums[]: "</span>&lt;&lt;x&lt;&lt;<span class="hljs-built_in">endl</span>;
        }
        <span class="hljs-keyword">return</span> nums[nums.size()-k];
    }
    <span class="hljs-comment">// 采用最优的quickSort方式</span>
    <span class="hljs-comment">// 1. 两者中取最短，为了减少递归层数</span>
    <span class="hljs-comment">// 2. 尾递归方式</span>
    <span class="hljs-comment">// 3. partition中利用三数取中</span>
    <span class="hljs-comment">// 4. 利用值交换方式代替swap</span>
    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">quickSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span>
    </span>{
        <span class="hljs-comment">// 2. 尾递归用while，普通情况if判断</span>
        <span class="hljs-keyword">while</span>(high-low &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-keyword">int</span> mid = low + ((high - low)&gt;&gt;<span class="hljs-number">1</span>);
            <span class="hljs-keyword">int</span> pivot = partition(nums, low, high);
            <span class="hljs-comment">// 1. 两者取短 + 尾递归优化，最坏空间复杂度优化至logn</span>
            <span class="hljs-keyword">if</span>(pivot &lt; mid)
            {
                quickSort(nums, low, pivot - <span class="hljs-number">1</span>);
                low = pivot + <span class="hljs-number">1</span>;
            }
            <span class="hljs-keyword">else</span>
            {
                quickSort(nums, pivot + <span class="hljs-number">1</span>, high);
                high = pivot - <span class="hljs-number">1</span>;
            }
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">partition</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> low, <span class="hljs-keyword">int</span> high)</span>
    </span>{
        <span class="hljs-comment">// 3. 省略三种取中</span>
        <span class="hljs-keyword">int</span> pivotKey = nums[low];
        <span class="hljs-keyword">while</span>(high-low &gt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-comment">//从两边向中间逼近，注意顺序一定不要写反</span>
            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[high] &gt;= pivotKey)
            {
                high -- ;
            }
            nums[low] = nums[high];
            <span class="hljs-keyword">while</span>(low &lt; high &amp;&amp; nums[low] &lt;= pivotKey)
            {
                low ++;
            }
            <span class="hljs-comment">// 4. 减少不必要的交换</span>
            nums[high] = nums[low];
        }
        <span class="hljs-comment">// 重点：减少不必要的交换后要还原nums[low]</span>
        nums[low] = pivotKey;
        <span class="hljs-keyword">return</span> low;
    }
};
</div></code></pre>
</li>
<li>思路三： stl::sort库
<ul>
<li>std::sort()内部实现处理形式不同
<ul>
<li>
<ol>
<li>数据量小时，利用insertSort()</li>
</ol>
</li>
<li>
<ol start="2">
<li>数据量大时，利用quickSort()</li>
</ol>
</li>
<li>
<ol start="3">
<li>栈深度过大时，采用heapSort()</li>
</ol>
</li>
</ul>
<pre class="hljs"><code><div>sort(nums.begin(),nums.end());
</div></code></pre>
</li>
</ul>
</li>
<li>思路四： priority_queue
<ul>
<li>
<ol>
<li>本质就是二叉堆，可以使用优先队列priority_queue</li>
</ol>
</li>
<li>
<ol start="2">
<li>维护一个k大小的小顶堆，堆顶就是第k个最大的数</li>
</ol>
</li>
<li>
<ol start="3">
<li>注意思路和方法</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span>
    </span>{
        <span class="hljs-comment">// priority_queue&lt;Type, Container, Functional&gt;</span>
        priority_queue&lt;<span class="hljs-keyword">int</span>,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;,greater&lt;<span class="hljs-keyword">int</span>&gt;&gt; pq;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> n : nums)
        {
            <span class="hljs-keyword">if</span> (pq.size() == k &amp;&amp; pq.top() &gt;= n)
                <span class="hljs-keyword">continue</span>;
            <span class="hljs-keyword">if</span> (pq.size() == k)
            {
                pq.pop();
            }
            pq.push(n);
        }
        <span class="hljs-keyword">return</span> pq.top();
    }
};
</div></code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<ul>
<li>思路五： heapSort(<strong>很棒的堆排序思路</strong>)
<ul>
<li>二叉堆</li>
<li>根节点索引 root / 2;</li>
<li>左子树索引 root * 2 + 1</li>
<li>右子树索引 root * 2 + 2;</li>
</ul>
</li>
<li>思路：
<ul>
<li>以大顶堆为例，分为「<strong>建堆</strong>」,「<strong>调整</strong>」和「<strong>删除</strong>」，如下图
<img src=".readme/heap_sort.gif" alt="" title="heapSort"></li>
<li>一. 构建堆
<ul>
<li>找到根节点进行遍历</li>
</ul>
</li>
<li>二. 调整堆
<ul>
<li>
<ol>
<li>找到根节点和其左右子树比较，找到最大的索引</li>
</ol>
</li>
<li>
<ol start="2">
<li>如果子树小于根节点，那么进行值交换</li>
</ol>
</li>
<li>
<ol start="3">
<li>进行向上迭代重复操作</li>
</ol>
</li>
</ul>
</li>
<li>三. 删除堆(大顶堆的根节点一定是最大值)
<ul>
<li>
<ol>
<li>进行循环删除的过程</li>
</ol>
</li>
<li>
<ol start="2">
<li>在删除将最后一个值赋值到第一个</li>
</ol>
</li>
<li>
<ol start="3">
<li>将heapSize大小减一</li>
</ol>
</li>
<li>
<ol start="4">
<li>将最大堆进行调整,调用步骤二</li>
</ol>
</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">findKthLargest</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span>
    </span>{
        <span class="hljs-keyword">int</span> heap_size = nums.size();
        <span class="hljs-comment">// 1. 建立堆</span>
        buildHeap(nums,heap_size);
        <span class="hljs-comment">// 3. 删除堆</span>
        <span class="hljs-comment">// 注意：1. index的&gt;=，而非&lt;= 2. for循环注意使用nums.size()，而非heap_size</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> index = nums.size()<span class="hljs-number">-1</span>; index &gt;= nums.size()-k+<span class="hljs-number">1</span>;index--)
        {
            swap(nums[<span class="hljs-number">0</span>],nums[index]);
            heap_size--;
            <span class="hljs-comment">// 重点：因为交换了nums[0],对顶堆0进行调整</span>
            maxHeap(nums,<span class="hljs-number">0</span>,heap_size);
        }
        <span class="hljs-keyword">return</span> nums[<span class="hljs-number">0</span>];
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildHeap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> heap_size)</span>
    </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> root_index = heap_size/<span class="hljs-number">2</span>;root_index &gt;= <span class="hljs-number">0</span>;root_index--)
        {
            <span class="hljs-comment">// 2. 调整堆</span>
            maxHeap(nums, root_index,heap_size);
        }
    }

    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">maxHeap</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> root_index,<span class="hljs-keyword">int</span> heap_size)</span>
    </span>{
        <span class="hljs-keyword">int</span> largest_index = root_index;
        <span class="hljs-keyword">int</span> left_index = root_index*<span class="hljs-number">2</span>+<span class="hljs-number">1</span>;
        <span class="hljs-keyword">int</span> right_index = root_index*<span class="hljs-number">2</span>+<span class="hljs-number">2</span>;
        <span class="hljs-comment">// 注意：nums[largest_index]中不能写root_index</span>
        <span class="hljs-keyword">if</span>(left_index&lt;heap_size &amp;&amp; nums[largest_index]&lt;nums[left_index])
        {
            largest_index = left_index;
        }
        <span class="hljs-keyword">if</span>(right_index&lt;heap_size &amp;&amp; nums[largest_index]&lt;nums[right_index])
        {
            largest_index = right_index;
        }
        <span class="hljs-keyword">if</span>(largest_index != root_index)
        {
            swap(nums[root_index],nums[largest_index]);
            <span class="hljs-comment">// 交换后largest_index为root的索引，进行largest_index递归</span>
            maxHeap(nums,largest_index,heap_size);
        }
    }
};
</div></code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<div id="tkfe" onclick="window.location.hash">
<h4 id="6-%E6%95%B0%E7%BB%84heapsort-top-k-frequent-elements347">6. [<strong>数组heapSort</strong>] top-k-frequent-elements(#347)</h4>
<p>linkage: <a href="https://leetcode-cn.com/problems/top-k-frequent-elements/" title="前K个高频元素">leetcode</a></p>
<ul>
<li>非空整数数组，返回其中出现频率前k高的元素</li>
<li>时间复杂度必须优于O(nlogn)</li>
<li>思路：heapSort实现(根据题4思路四实现)
<ul>
<li>利用map和priority_queue实现</li>
<li>
<ol>
<li>注意临时变量的生命</li>
</ol>
</li>
<li>
<ol start="2">
<li>注意push pair的次序，和pair的比较准则</li>
</ol>
<pre class="hljs"><code><div><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Solution</span> {</span>
<span class="hljs-keyword">public</span>:
    <span class="hljs-function"><span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; <span class="hljs-title">topKFrequent</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums, <span class="hljs-keyword">int</span> k)</span> 
    </span>{
        <span class="hljs-comment">// priority_queue&lt;Type, Container, Functional&gt;</span>
        priority_queue&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;,<span class="hljs-built_in">vector</span>&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;,greater&lt;<span class="hljs-built_in">std</span>::pair&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt;&gt;&gt; pq;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">unordered_map</span>&lt;<span class="hljs-keyword">int</span>,<span class="hljs-keyword">int</span>&gt; counter;
        <span class="hljs-built_in">std</span>::<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt; res;
        <span class="hljs-comment">// 添加元素并计数</span>
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">auto</span> x: nums)
        {
            counter[x]++;
        }
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> pair : counter)
        {
            <span class="hljs-comment">// pair的比较，先比较第一个元素，第一个相等比较第二个</span>
            pq.push(<span class="hljs-built_in">std</span>::make_pair(pair.second, pair.first));
            <span class="hljs-keyword">if</span> (pq.size() &gt; k) pq.pop();
        }
        <span class="hljs-keyword">while</span>(!pq.empty())
        {
            res.push_back(pq.top().second);
            pq.pop();
        }
        <span class="hljs-keyword">return</span> res;
    }
};
</div></code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<div id="bubbleSort" onclick="window.location.hash">
<h4 id="7-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-bubblesort">7. [代码框架] bubbleSort</h4>
<ul>
<li>排序思想：
<ul>
<li>
<p>传统思路</p>
<ul>
<li>两两比较相邻的关键字，反序进行交换，如下图
<img src=".readme/bubble_sort.gif" alt="" title="bubbleSort"></li>
<li>但这样排序效率较为低效</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span>
    </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= nums.size()<span class="hljs-number">-2</span>;i++)
        {
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =i+<span class="hljs-number">1</span>;j&lt;=nums.size()<span class="hljs-number">-1</span>;j++)
            {
                <span class="hljs-keyword">if</span>(nums[i]&gt;nums[j])
                    swap(nums[i],nums[j]);
            }
        }
    }
</div></code></pre>
</li>
<li>
<p>改进一：</p>
<ul>
<li>内层遍历从后向前</li>
<li>比较前者大于后者进行值交换</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span>
</span>{
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= nums.size()<span class="hljs-number">-2</span>;i++)
    {
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =nums.size()<span class="hljs-number">-1</span>;j&gt;i;j--)
        {
            <span class="hljs-comment">// 比较前者大于后者进行值交换</span>
            <span class="hljs-keyword">if</span>(nums[j<span class="hljs-number">-1</span>]&gt;nums[j])
                swap(nums[j<span class="hljs-number">-1</span>],nums[j]);
        }
    }
}
</div></code></pre>
</li>
<li>
<p>改进二：</p>
<ul>
<li>利用flag标记，有数据交换进行排序</li>
<li>针对部分有序</li>
</ul>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">bubbleSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span>
</span>{
    <span class="hljs-keyword">bool</span> flag = <span class="hljs-literal">true</span>;
    <span class="hljs-comment">// 注意flag的放置条件</span>
    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= nums.size()<span class="hljs-number">-2</span> &amp;&amp; flag;i++)
    {
        flag = <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =nums.size()<span class="hljs-number">-1</span>;j&gt;i;j--)
        {
            <span class="hljs-keyword">if</span>(nums[j<span class="hljs-number">-1</span>]&gt;nums[j])
            {
                swap(nums[j<span class="hljs-number">-1</span>],nums[j]);
                <span class="hljs-comment">// 如果后面每一个元素都大于前面，则部分有序，提高效率</span>
                flag = <span class="hljs-literal">true</span>;
            }
        }
    }
}
</div></code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<div id="selectSort" onclick="window.location.hash">
<h4 id="8-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-selectsort">8. [代码框架] selectSort</h4>
<ul>
<li>排序思想：
<ul>
<li>通过当前值与其他值比较</li>
<li>找到最小值的索引</li>
<li>如果索引非当前索引，进行值交换，如下图
<img src=".readme/select_sort.gif" alt="" title="selectSort"><pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">selectSort</span><span class="hljs-params">(<span class="hljs-built_in">vector</span>&lt;<span class="hljs-keyword">int</span>&gt;&amp; nums)</span>
    </span>{
        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt;= nums.size()<span class="hljs-number">-2</span>;i++)
        {
            <span class="hljs-keyword">int</span> min_index = i;
            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> j =nums.size()<span class="hljs-number">-1</span>;j&gt;i;j--)
            {
                <span class="hljs-keyword">if</span>(nums[min_index]&gt;nums[j])
                {
                    min_index = j;
                }
            }
            <span class="hljs-keyword">if</span>(i != min_index)
            {
                swap(nums[i],nums[min_index]);
            }
        }
    }
</div></code></pre>
</li>
</ul>
</li>
</ul>
<hr>
<div id="insertSort" onclick="window.location.hash">
<h4 id="9-%E4%BB%A3%E7%A0%81%E6%A1%86%E6%9E%B6-insertsort">9. [代码框架] insertSort</h4>
<ul>
<li>排序思想：</li>
</ul>

</body>
</html>
